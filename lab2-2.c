#include <stdio.h>#include <stdlib.h>#include <sys/mman.h>#include <sys/types.h>#include <sys/stat.h>#include <fcntl.h>#include <unistd.h>int nloop = 50;/**********************************************************\ * Structure: creates Peterson variable data types to     * *  group for further use.                                *                                     **********************************************************/typedef struct Peterson_Variables {    int turn;    int flag[2];}pv;/**********************************************************\ * Function: increment a counter by some amount one by one * * argument: ptr (address of the counter), increment       * * output  : nothing                                       * **********************************************************/void add_n(int *ptr, int increment){  int i,j;  for (i=0; i < increment; i++){    *ptr = *ptr + 1;    for (j=0; j < 1000000;j++);  }}/**********************************************************\ * Function: initialize peterson variables                 * * argument: ptr (address of peterson variable)            * * output:  none                                           * **********************************************************/void initialize (pv *v) {    v->flag[0] = 0;    v->flag[1] = 0;}int main(){    int pid;        /* Process ID                     */    int *countptr;  /* pointer to the counter         */    int fd;     /* file for containing my counter */    int zero = 0; /* a temp variable containing 0 */    system("rm -f counter");    /* create a file which will contain shared variable */    fd = open("counter",O_RDWR | O_CREAT);    write(fd,&zero,sizeof(int));    /* map my file to memory */    countptr = (int *) mmap(NULL, sizeof(int),PROT_READ | PROT_WRITE, MAP_SHARED, fd,0);    if (!countptr) {        printf("Mapping failed\n");        exit(1);    }    *countptr = 0;    close(fd);        /* have system remove petfile (Peterson's file) to prevent writing issues*/    system("rm -f petfile");    int pet; /* file for containing my variables */    pv *vs;    pet = open("petfile", O_RDWR | O_CREAT);    write(pet, &zero, sizeof(pv));        /* map my file to memory */    vs  = (pv *) mmap(NULL, sizeof(pv), PROT_READ | PROT_WRITE, MAP_SHARED, pet, 0);           if(!vs) {        printf("Unable to map variables");        exit(1);    }        /* initialize peterson variables then close petfile */    initialize(vs);    close(pet);    pid = fork();       if (pid == 0) {    	    	        while(1) {         /* initialization*/		            vs->flag[0] = 1;            vs->turn = 1;         /* entry into critical section*/            while(vs->flag[1] == 1 && vs->turn == 1);         /* critical section begins*/          /* The child increments the counter by two's */            if (*countptr < nloop) {                add_n(countptr,2);                printf("Child process -->> counter = %d\n", *countptr);            }         else {                vs->flag[0] = 0;                close(pet);                close(fd);                break;            }         /* exit critical section, allow parent process to enter*/            vs->flag[0] = 0;            close(pet);            close(fd);        }    }    else {    	        while(1) {         /* initialization*/	            vs->flag[1] = 1;            vs->turn = 0;         /* entry into critical section*/            while(vs->flag[0] == 1 && vs->turn == 0);         /* critical section begins*/             /* The parent increments the counter by twenty's */            if (*countptr < nloop) {                add_n(countptr, 20);                printf("Parent process -->> counter = %d\n", *countptr);            }         else {                vs->flag[1] = 0;                close(pet);                close(fd);                break;            }        /* exit critical section, allow child process to enter*/             vs->flag[1] = 0;            close(pet);            close(fd);        }    }}